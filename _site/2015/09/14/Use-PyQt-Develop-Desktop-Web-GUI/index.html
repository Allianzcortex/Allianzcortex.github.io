<!DOCTYPE html>

<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>使用 PyQT 来开发一个桌面客户端</title>
  <meta name="description" content="Python 的动态机制结合 Qt 的信号槽；读取数据库并展示 写了一个能检测网络连接的程序。界面截图如下： 以后写客户端的机会还是挺少的…就不过多地追求最佳实践了，只需要能做出一个“能戳戳点点的 GUI ”就够了⊙﹏⊙b ui 和界面对应 PyQt 本身和 Qt 的信号槽机制是类似的。点击一个按钮后会发送出一个信号，需要定义该信号的处理机制。 设计界面直接用 designer 来设计。拖动 button/listview/model，然后自定义名称。 生成 .ui 文件后，用 pyuic4 –x ping_ui.ui –o ping_ui.py 就可以看到 ping_ui.py 文件里包含了 class Ui_Form(object),里面已经定义好了各种长度/位置，比手写方便多了。 再自定义一个 pyqt_example2.py ，里面包含了如下文件： class CalculateForm(QWidget): def __init__(self, parent=None): super(CalculateForm, self).__init__(parent) self.ui = Ui_Form() self.ui.setupUi(self) 再定义执行函数： if __name__ == &#39;__main__&#39;: app = QApplication(sys.argv) calculator = CalculateForm() calculator.show() sys.exit(app.exec_()) 执行后就可以看到界面已经成功显示。 接下来就是要建立信号槽机制，比如在当初定义 ui 的 button 时有一个 button 的名称为 add_url 。我们希望将它与 add_url 的函数对应在一起，只需定义如下（最好在 init 里）： self.ui.add_url.clicked.connect(self.add_url_func) # 点击函数 数据库的增删改查以及显示 在 PyQt 中定义的　model 的是 QSqlTableModel,定义显示 table 的是　listview。 比如说定义 initialize_model() 的方法： db = QtSql.QSqlDatabase.addDatabase(&#39;QSQLITE&#39;) db.setDatabaseName(&#39;test_ping.db&#39;) def initialize_model(model): model.setTable(&#39;url_ping&#39;) model.setEditStrategy(QtSql.QSqlTableModel.OnManualSubmit) model.select() model.setHeaderData(0, QtCore.Qt.Horizontal, u&quot;网址&quot;) # 对应的 url 链接 而要进行显示，只需要将 listview 和对应的 model 连接起来: def show_view(self): model = QSqlTableModel() initialize_model(model) self.ui.url_list.setModel(model) # self.ui.url_list 是一个 listview self.ui.url_list.show() 每次在进行增删改查之后只要调用 self.show_view() 方法，就能看到最新的数据库，等效于刷新～ 如何执行查询 比如要查找包含 ‘test’的内容： query = QtSql.QSqlQuery() query.exec_(&quot;select * from test where value like &#39;%test%&#39;&quot;) 而如果要展示，更好的方法是重新定义 QSqlQueryModel sqlQueryModel.setQuery(&quot;select * from test where value like &#39;%test%&#39; &quot;) self.ui.url_list.setModel(sqlQueryModel) self.ui.url_list.show() 定义弹出框：使用最简单的如下函数就可以了： def show_messagebox(self): msg = QMessageBox() msg.setText(u&#39;检测成功&#39;) msg.setStandardButtons(QMessageBox.Ok) msg.exec_() ui 和执行线程分离 如何设置 ui 和执行任务线程分离，使得界面不会阻塞卡死： 这个有很多方法来去做，我选择的是如下方法： from PyQt4.QtCore import QThread class PingThread(QThread): &quot;&quot;&quot; 定义 PingThread &quot;&quot;&quot; def __init__(self, url): QThread.__init__(self) self._url = url def run(self): ping_url(self._url) self.emit(SIGNAL(&#39;ping url&#39;)) return &quot;&quot;&quot; 接下来在主线程中调用即可 &quot;&quot;&quot; self.pingThread = PingThread(target_url) # self.connect(self.pingThread, SIGNAL(&#39;ping url&#39;), self.show_messagebox) 可选 self.pingThread.start() 进度条 PyQt 中进度条使用 QProgressBar 来展现。在 ui 中设置时会有最小值（默认为 0 ）和最大值（默认为 100 ）。 在更新时只要设置 self.ui.click_progrress.setValue(30) # 进度条进展到 30% 程度 # click_progress 是 ui 里对应的 ProgressBar 其他 ping 调用的是系统自带的 ping 接口 tracert 则调用的是 windows 里的 tracert 接口（Linux 下对应的是 traceroute） telnet 是检测端口是否打开。然后直接调用系统命令的话有两个弊端： ① Windows 需要用户手动开启配置 ② telnet 采用的是光标是否闪烁去判断端口状况，没有返回值，不方便程序处理。 所以最后采用 socket 来连接： sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) result = sock.connect_ex((url_name, 80)) port_open = True if result == 0 else False PyQt 自带的在 site-packages 里的好多 demo 都非常好，直接要用的话看代码比文档会更快～ 在学的时候写了一个增正版的计算器 demo，当输入的数字或者选择的计算符号发生变化时，会自动改变计算结果（嗯，用的就是 eval()～），用的是 Python 的 装饰器特性。">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/2015/09/14/Use-PyQt-Develop-Desktop-Web-GUI/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Allianzcortex-Blog" href="http://localhost:4000/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="hzcortex">
  <meta name="twitter:title" content="使用 PyQT 来开发一个桌面客户端">
  <meta name="twitter:description" content="Python 的动态机制结合 Qt 的信号槽；读取数据库并展示 写了一个能检测网络连接的程序。界面截图如下： 以后写客户端的机会还是挺少的…就不过多地追求最佳实践了，只需要能做出一个“能戳戳点点的 GUI ”就够了⊙﹏⊙b ui 和界面对应 PyQt 本身和 Qt 的信号槽机制是类似的。点击一个按钮后会发送出一个信号，需要定义该信号的处理机制。 设计界面直接用 designer 来设计。拖动...">
  
    <meta name="twitter:creator" content="hzcortex">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Allianzcortex-Blog</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/projects/">Projects</a>
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/board/">board</a>
      
        
        <a class="page-link" href="/feed.xml">RSS</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">使用 PyQT 来开发一个桌面客户端</h1>
    
    <p class="post-meta"><time datetime="2015-09-14T16:46:30-03:00" itemprop="datePublished">Sep 14, 2015</time> • 
  
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Python 的动态机制结合 Qt 的信号槽；读取数据库并展示
<!-- more --></p>

<p>写了一个能检测网络连接的程序。界面截图如下：</p>

<p><img src="/images/pyqt-example.png" alt="PyQt" /></p>

<p>以后写客户端的机会还是挺少的…就不过多地追求最佳实践了，只需要能做出一个“能戳戳点点的 GUI ”就够了⊙﹏⊙b</p>

<h4 id="ui-和界面对应">ui 和界面对应</h4>

<p>PyQt 本身和 Qt 的信号槽机制是类似的。点击一个按钮后会发送出一个信号，需要定义该信号的处理机制。</p>

<p>设计界面直接用 designer 来设计。拖动 button/listview/model，然后自定义名称。</p>

<p>生成 .ui 文件后，用 <code class="highlighter-rouge">pyuic4 –x ping_ui.ui –o ping_ui.py</code> 就可以看到 ping_ui.py 文件里包含了 <code class="highlighter-rouge">class Ui_Form(object)</code>,里面已经定义好了各种长度/位置，比手写方便多了。</p>

<p>再自定义一个 <code class="highlighter-rouge">pyqt_example2.py</code> ，里面包含了如下文件：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">CalculateForm</span><span class="p">(</span><span class="n">QWidget</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CalculateForm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ui</span> <span class="o">=</span> <span class="n">Ui_Form</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">setupUi</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></pre></figure>

<p>再定义执行函数：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">QApplication</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
    <span class="n">calculator</span> <span class="o">=</span> <span class="n">CalculateForm</span><span class="p">()</span>
    <span class="n">calculator</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">exec_</span><span class="p">())</span></code></pre></figure>

<p>执行后就可以看到界面已经成功显示。</p>

<p>接下来就是要建立信号槽机制，比如在当初定义 ui 的 button 时有一个 button 的名称为 add_url 。我们希望将它与 add_url 的函数对应在一起，只需定义如下（最好在 <strong>init</strong> 里）：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">add_url</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_url_func</span><span class="p">)</span> <span class="c"># 点击函数</span></code></pre></figure>

<h4 id="数据库的增删改查以及显示">数据库的增删改查以及显示</h4>

<p>在 PyQt 中定义的　model 的是 QSqlTableModel,定义显示 table 的是　listview。
比如说定义 initialize_model() 的方法：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">db</span> <span class="o">=</span> <span class="n">QtSql</span><span class="o">.</span><span class="n">QSqlDatabase</span><span class="o">.</span><span class="n">addDatabase</span><span class="p">(</span><span class="s">'QSQLITE'</span><span class="p">)</span>
<span class="n">db</span><span class="o">.</span><span class="n">setDatabaseName</span><span class="p">(</span><span class="s">'test_ping.db'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">initialize_model</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="n">model</span><span class="o">.</span><span class="n">setTable</span><span class="p">(</span><span class="s">'url_ping'</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">setEditStrategy</span><span class="p">(</span><span class="n">QtSql</span><span class="o">.</span><span class="n">QSqlTableModel</span><span class="o">.</span><span class="n">OnManualSubmit</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
    <span class="n">model</span><span class="o">.</span><span class="n">setHeaderData</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">QtCore</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">Horizontal</span><span class="p">,</span> <span class="s">u"网址"</span><span class="p">)</span> <span class="c"># 对应的 url 链接</span></code></pre></figure>

<p>而要进行显示，只需要将 listview 和对应的 model 连接起来:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">show_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">QSqlTableModel</span><span class="p">()</span>
    <span class="n">initialize_model</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">url_list</span><span class="o">.</span><span class="n">setModel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="c"># self.ui.url_list 是一个 listview
</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">url_list</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></figure>

<p>每次在进行增删改查之后只要调用 self.show_view() 方法，就能看到最新的数据库，等效于刷新～</p>

<h5 id="如何执行查询">如何执行查询</h5>

<p>比如要查找包含 ‘test’的内容：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">query</span> <span class="o">=</span> <span class="n">QtSql</span><span class="o">.</span><span class="n">QSqlQuery</span><span class="p">()</span>
<span class="n">query</span><span class="o">.</span><span class="n">exec_</span><span class="p">(</span><span class="s">"select * from test where value like '</span><span class="si">%</span><span class="s">test</span><span class="si">%</span><span class="s">'"</span><span class="p">)</span></code></pre></figure>

<p>而如果要展示，更好的方法是重新定义 QSqlQueryModel</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">sqlQueryModel</span><span class="o">.</span><span class="n">setQuery</span><span class="p">(</span><span class="s">"select * from test where value like '</span><span class="si">%</span><span class="s">test</span><span class="si">%</span><span class="s">' "</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">url_list</span><span class="o">.</span><span class="n">setModel</span><span class="p">(</span><span class="n">sqlQueryModel</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">url_list</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></figure>

<p>定义弹出框：使用最简单的如下函数就可以了：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">show_messagebox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">QMessageBox</span><span class="p">()</span>
    <span class="n">msg</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s">u'检测成功'</span><span class="p">)</span>
    <span class="n">msg</span><span class="o">.</span><span class="n">setStandardButtons</span><span class="p">(</span><span class="n">QMessageBox</span><span class="o">.</span><span class="n">Ok</span><span class="p">)</span>
    <span class="n">msg</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span></code></pre></figure>

<h4 id="ui-和执行线程分离">ui 和执行线程分离</h4>

<p>如何设置 ui 和执行任务线程分离，使得界面不会阻塞卡死：</p>

<p>这个有很多方法来去做，我选择的是如下方法：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">PyQt4.QtCore</span> <span class="kn">import</span> <span class="n">QThread</span>

<span class="k">class</span> <span class="nc">PingThread</span><span class="p">(</span><span class="n">QThread</span><span class="p">):</span>
    <span class="s">""" 定义 PingThread """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="n">QThread</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_url</span> <span class="o">=</span> <span class="n">url</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ping_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_url</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">SIGNAL</span><span class="p">(</span><span class="s">'ping url'</span><span class="p">))</span>
        <span class="k">return</span>

<span class="s">""" 接下来在主线程中调用即可 """</span>

<span class="bp">self</span><span class="o">.</span><span class="n">pingThread</span> <span class="o">=</span> <span class="n">PingThread</span><span class="p">(</span><span class="n">target_url</span><span class="p">)</span>
<span class="c"># self.connect(self.pingThread, SIGNAL('ping url'), self.show_messagebox) 可选
</span>
<span class="bp">self</span><span class="o">.</span><span class="n">pingThread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span></code></pre></figure>

<h4 id="进度条">进度条</h4>

<p>PyQt 中进度条使用 QProgressBar 来展现。在 ui 中设置时会有最小值（默认为 0 ）和最大值（默认为 100 ）。
在更新时只要设置</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">click_progrress</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="c"># 进度条进展到 30% 程度
</span>
<span class="c"># click_progress 是 ui 里对应的 ProgressBar</span></code></pre></figure>

<h4 id="其他">其他</h4>

<p>ping 调用的是系统自带的 ping 接口</p>

<p>tracert 则调用的是 windows 里的 tracert 接口（Linux 下对应的是 traceroute）</p>

<p>telnet 是检测端口是否打开。然后直接调用系统命令的话有两个弊端：</p>

<p>① Windows 需要用户手动开启配置</p>

<p>② telnet 采用的是光标是否闪烁去判断端口状况，没有返回值，不方便程序处理。</p>

<p>所以最后采用 socket 来连接：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">connect_ex</span><span class="p">((</span><span class="n">url_name</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="n">port_open</span> <span class="o">=</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">False</span></code></pre></figure>

<p>PyQt 自带的在 site-packages 里的好多 demo 都非常好，直接要用的话看代码比文档会更快～
在学的时候写了一个增正版的计算器 demo，当输入的数字或者选择的计算符号发生变化时，会自动改变计算结果（嗯，用的就是 eval()～），用的是 Python 的 装饰器特性。</p>

  </div>

</article>

        
<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'allianzcortex-me'; // required: replace example with your forum shortname
        // var disqus_developer = 1; // Comment out when the site is live
        var disqus_identifier = "/2015/09/14/Use-PyQt-Develop-Desktop-Web-GUI/";

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



    </main>
    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Pro Land
    </p>

  </div>

</footer>


  </body>

</html>
