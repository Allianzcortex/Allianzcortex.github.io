<!DOCTYPE html>

<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Python 中的引用机制</title>
  <meta name="description" content="解决 No module named 和 Attempted relative import 这两个问题 两个引用时最常见的问题 No module named XXXz 在编译时遇到 No Module Named XX 。这个问题曾经遇到过，并且用命令行执行时会报错，但用 Pycharm 的运行按钮就可以顺利执行。最后发现错误的过程也很简&amp;gt;单，在编辑配置一项里勾选 “show command line afterwards”，然后执行　import sys;sys.path 命令，和在命令行里的选项进行对比，发现前者多了一个 /home/hzcortex/projects... 的模块。也就是说 Python 并没有把执行命令的这个脚本所在的目录加入 sys.path 中。 解决方法是在报错的文件目录下加入： import sys from os import path sys.path.append(path.dirname(path.dirname(path.abspath(__file__)))) import sys from os import path sys.path.append(path.dirname(path.dirname(path.abspath(__file__)))) Attempted relative import in non package 这个问题要分两类来进行讨论： ① 在引用的时候确实发生了循环引用，A 要引用 B，B 要引用 C，而 C 同时要引用 B 里的一个函数。这时通常的解决办法是修改 C 文件的引用顺序，把 import 语句放到需要使用引用对象的语句前(参考 《Python 核心编程》 的说法)。最近在开发 FBRank 的时候确实遇到了这个问题，项目结构是这样的： └── utils ├── exceptions.py ├── __init__.py # utils.py from .exceptions import NotSupprotedYetException def check_before(attr=&#39;name&#39;): ... raise NotSupprotedYetException ... # exceptions.py from .utils import github_url, connect_url class NotSupprotedYetException(FBRankException): &quot;&quot;&quot;still not supprt &quot;&quot;&quot; 之后在执行程序的时候出现了这样的错误： File &quot;/home/hzcortex/FBRank/FBRank/parse/League.py&quot;, line 13, in &amp;lt;module&amp;gt; from FBRank.utils.exceptions import IllegalArgumentException, NotSupprotedYetException File &quot;/home/hzcortex/FBRank/FBRank/utils/exceptions.py&quot;, line 2, in &amp;lt;module&amp;gt; from .utils import github_url, connect_url File &quot;/home/hzcortex/FBRank/FBRank/utils/utils.py&quot;, line 5, in &amp;lt;module&amp;gt; from .exceptions import NotSupprotedYetException ImportError: cannot import name &#39;NotSupprotedYetException&#39; 自上而下看调用的顺序，在 /exceptions.py 里从 .utils.py 调用了 github_url, connect_url 这两个变量，而在调用 .utils.py 时又从 /exceptions.py 调用了 NotSupprotedYetException，这样就互相循环，永远都无法解决引入。解决办法就是只在需要使用的函数时再加载： # utils.py def check_before(attr=&#39;name&#39;): from .exceptions import NotSupprotedYetException # ...... 因为 Python 的引用机制并不会重新引入之前已经引入的包(需要的话要用 imp.reaload())，所以不用担心这种引入会对性能产生影响 ② 如果确实没有循环引用，那么通常是如下的情况： 拿之前写的一个从 Kafka 向 ES 导数据的程序来举例子。整个程序的结构如下(好像紫色对比度比较高…)： 在主程序 RealtimeLogToES.py 里有如下的引用： 如果在这种情况下进入到 RLTES 目录里直接执行 python RealtimeLogToES.py，那么就会报上面的循环引用的错。 解决方法再有以下两种： ① 将 from .config import 改为和下面一样的绝对引用，from RLTES.config import ② 不修改代码，退回到上一层目录,cd ..，之后执行 python -m RLTES.RealtimeLogToES Python 在进行相对引入的时候，判断的根据是当前文件的 name 属性。而当你执行一个文件的时候，该文件原有的 name 属性被替代为了固定的 ‘main‘,所以相对引入就无法工作，而绝对引入是没有问题的。在命令行里加入-m 后，告诉 Python 解释器应该将这个文件作为一个脚本来运行。 为什么会发生这种问题 要真正理解 Python 的 import 机制是如何查找变量的。 到底怎么引用 PEP8 里建议是一直用绝对引用，但就像那个 annoying double underscore 一样，不喜欢绝对引用的也大有人在。 团队里面保持一致即可。就个人开发来说，还是更喜欢单层采用用 .import，其他用绝对引用。 在 《Two Scopes Of Django》 一书里明确说明了禁止使用如 from A import a 这样的 implicit import 语句，但考虑到很多时候写脚本并不会具体到一个大的工程，而是在服务器上建立一个目录去完成一个特定的功能，如果这么写能方便调试和部署，那么也没有大的问题。 __init__.py 的作用 __init__.py 最重要的作用就是标记含有该 __init__.py 目录的文件夹为一个 package ，从而完成对应的引入。 大部分情况下 __init__.py 里什么内容也不用写，如果一定要写的话基本有以下三个作用： 写 __author__ 等有关信息 写一个 __all__ 的配置，精确定义在 from x import * 时候会引入的内容 如果说前两个都无关紧要的话，那么最后一个就比较多了，可以简化引入方式，用来控制 API 的稳定性。 还是拿写的 FBRank 来举例子。虽然你看在 README 里写的是只支持命令行工具，但其实它也提供了在代码里引入的能力。举个例子： # 想要引入某个异常，需要具体到对应的文件 In [1]: from FBRank.utils.exceptions import IllegalArgumentException # 但想要引入某个类，只要具体到对应的 package 就可以了 In [2]: from FBRank.object import Club # 具体原因是在 FBRank/object 下的 __init__.py 里有如下代码 from .League import League from .Club import Club from .Player import Player">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/2015/03/11/Python-Import-Mechanism/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Allianzcortex-Blog" href="http://localhost:4000/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="hzcortex">
  <meta name="twitter:title" content="Python 中的引用机制">
  <meta name="twitter:description" content="解决 No module named 和 Attempted relative import 这两个问题 两个引用时最常见的问题 No module named XXXz 在编译时遇到 No Module Named XX 。这个问题曾经遇到过，并且用命令行执行时会报错，但用 Pycharm 的运行按钮就可以顺利执行。最后发现错误的过程也很简&amp;gt;单，在编辑配置一项里勾选 “sho...">
  
    <meta name="twitter:creator" content="hzcortex">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Allianzcortex-Blog</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="/projects/">Projects</a>
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/board/">board</a>
      
        
        <a class="page-link" href="/feed.xml">RSS</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Python 中的引用机制</h1>
    
    <p class="post-meta"><time datetime="2015-03-11T10:29:10-03:00" itemprop="datePublished">Mar 11, 2015</time> • 
  
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>解决 <code class="highlighter-rouge">No module named</code> 和 <code class="highlighter-rouge">Attempted relative import</code> 这两个问题
<!-- more --></p>

<h2 id="两个引用时最常见的问题">两个引用时最常见的问题</h2>

<h3 id="no-module-named-xxxz">No module named XXXz</h3>

<p>在编译时遇到 <code class="highlighter-rouge">No Module Named XX</code> 。这个问题曾经遇到过，并且用命令行执行时会报错，但用 Pycharm 的运行按钮就可以顺利执行。最后发现错误的过程也很简&gt;单，在编辑配置一项里勾选 “show command line afterwards”，然后执行　<code class="highlighter-rouge">import sys;sys.path</code> 命令，和在命令行里的选项进行对比，发现前者多了一个 <code class="highlighter-rouge">/home/hzcortex/projects...</code> 的模块。也就是说 Python 并没有把执行命令的这个脚本所在的目录加入 sys.path 中。</p>

<hr />

<p>解决方法是在报错的文件目录下加入：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">path</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">__file__</span><span class="p">))))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">path</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">__file__</span><span class="p">))))</span></code></pre></figure>

<h3 id="attempted-relative-import-in-non--package">Attempted relative import in non  package</h3>

<p>这个问题要分两类来进行讨论：</p>

<p>① 在引用的时候确实发生了循环引用，A 要引用 B，B 要引用 C，而 C 同时要引用 B 里的一个函数。这时通常的解决办法是修改 C 文件的引用顺序，把 <code class="highlighter-rouge">import</code> 语句放到需要使用引用对象的语句前(参考 《Python 核心编程》 的说法)。最近在开发 <a href="https://github.com/Allianzcortex/FBRank">FBRank</a> 的时候确实遇到了这个问题，项目结构是这样的：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">└──</span> <span class="n">utils</span>
    <span class="err">├──</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">py</span>
    <span class="err">├──</span> <span class="n">__init__</span><span class="o">.</span><span class="n">py</span>

<span class="c"># utils.py
</span>
 <span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="n">NotSupprotedYetException</span>

<span class="k">def</span> <span class="nf">check_before</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s">'name'</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">raise</span> <span class="n">NotSupprotedYetException</span>
    <span class="o">...</span>

<span class="c"># exceptions.py
</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">github_url</span><span class="p">,</span> <span class="n">connect_url</span>

<span class="k">class</span> <span class="nc">NotSupprotedYetException</span><span class="p">(</span><span class="n">FBRankException</span><span class="p">):</span>
    <span class="s">"""still not supprt
    """</span></code></pre></figure>

<p>之后在执行程序的时候出现了这样的错误：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>File "/home/hzcortex/FBRank/FBRank/parse/League.py", line 13, in &lt;module&gt;
    from FBRank.utils.exceptions import IllegalArgumentException, NotSupprotedYetException
  File "/home/hzcortex/FBRank/FBRank/utils/exceptions.py", line 2, in &lt;module&gt;
    from .utils import github_url, connect_url
  File "/home/hzcortex/FBRank/FBRank/utils/utils.py", line 5, in &lt;module&gt;
    from .exceptions import NotSupprotedYetException
ImportError: cannot import name 'NotSupprotedYetException'

</code></pre>
</div>
<p>自上而下看调用的顺序，在 /exceptions.py 里从 .utils.py 调用了 <code class="highlighter-rouge">github_url, connect_url</code> 这两个变量，而在调用 .utils.py 时又从 /exceptions.py 调用了 NotSupprotedYetException，这样就互相循环，永远都无法解决引入。解决办法就是只在需要使用的函数时再加载：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># utils.py
</span>

<span class="k">def</span> <span class="nf">check_before</span><span class="p">(</span><span class="n">attr</span><span class="o">=</span><span class="s">'name'</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="n">NotSupprotedYetException</span>
    <span class="c"># ......</span></code></pre></figure>

<p>因为 Python 的引用机制并不会重新引入之前已经引入的包(需要的话要用 <code class="highlighter-rouge">imp.reaload()</code>)，所以不用担心这种引入会对性能产生影响</p>

<p>② 如果确实没有循环引用，那么通常是如下的情况：</p>

<p>拿之前写的一个从 Kafka 向 ES 导数据的程序来举例子。整个程序的结构如下(好像紫色对比度比较高…)：</p>

<p><img src="/images/RLTES-2.png" alt="RLTES-Project" /></p>

<p>在主程序 <code class="highlighter-rouge">RealtimeLogToES.py</code> 里有如下的引用：</p>

<p><img src="/images/RLTES-1.png" alt="RLTES-import" /></p>

<p>如果在这种情况下进入到 RLTES 目录里直接执行 <code class="highlighter-rouge">python RealtimeLogToES.py</code>，那么就会报上面的循环引用的错。</p>

<p>解决方法再有以下两种：</p>

<p>① 将 <code class="highlighter-rouge">from .config import</code> 改为和下面一样的绝对引用，<code class="highlighter-rouge">from RLTES.config import</code></p>

<p>② 不修改代码，退回到上一层目录,<code class="highlighter-rouge">cd ..</code>，之后执行 <code class="highlighter-rouge">python -m RLTES.RealtimeLogToES</code></p>

<p>Python 在进行相对引入的时候，判断的根据是当前文件的 <strong>name</strong> 属性。而当你执行一个文件的时候，该文件原有的 <strong>name</strong> 属性被替代为了固定的 ‘<strong>main</strong>‘,所以相对引入就无法工作，而绝对引入是没有问题的。在命令行里加入-m 后，告诉 Python 解释器应该将这个文件作为一个脚本来运行。</p>

<h5 id="为什么会发生这种问题">为什么会发生这种问题</h5>

<p>要真正理解 Python 的 import 机制是如何查找变量的。</p>

<h5 id="到底怎么引用">到底怎么引用</h5>

<p>PEP8 里建议是一直用绝对引用，但就像那个 <code class="highlighter-rouge">annoying double underscore</code> 一样，不喜欢绝对引用的也大有人在。</p>

<p>团队里面保持一致即可。就个人开发来说，还是更喜欢单层采用用 .import，其他用绝对引用。</p>

<p>在 <strong>《Two Scopes Of Django》</strong> 一书里明确说明了禁止使用如 <code class="highlighter-rouge">from A import a</code> 这样的 <strong>implicit import</strong> 语句，但考虑到很多时候写脚本并不会具体到一个大的工程，而是在服务器上建立一个目录去完成一个特定的功能，如果这么写能方便调试和部署，那么也没有大的问题。</p>

<h5 id="__init__py-的作用"><code class="highlighter-rouge">__init__.py</code> 的作用</h5>

<p><code class="highlighter-rouge">__init__.py</code> 最重要的作用就是标记含有该 <code class="highlighter-rouge">__init__.py</code> 目录的文件夹为一个 package ，从而完成对应的引入。</p>

<p>大部分情况下 <code class="highlighter-rouge">__init__.py</code> 里什么内容也不用写，如果一定要写的话基本有以下三个作用：</p>

<ul>
  <li>
    <p>写 <code class="highlighter-rouge">__author__</code> 等有关信息</p>
  </li>
  <li>
    <p>写一个 <code class="highlighter-rouge">__all__</code> 的配置，精确定义在 <code class="highlighter-rouge">from x import *</code> 时候会引入的内容</p>
  </li>
  <li>
    <p>如果说前两个都无关紧要的话，那么最后一个就比较多了，可以简化引入方式，用来控制 API 的稳定性。</p>

    <p>还是拿写的 <a href="github.com/Allianzcortex/FBRank">FBRank</a> 来举例子。虽然你看在 README 里写的是只支持命令行工具，但其实它也提供了在代码里引入的能力。举个例子：</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python">  <span class="c"># 想要引入某个异常，需要具体到对应的文件
</span>
  <span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">from</span> <span class="nn">FBRank.utils.exceptions</span> <span class="kn">import</span> <span class="n">IllegalArgumentException</span>

  <span class="c"># 但想要引入某个类，只要具体到对应的 package 就可以了
</span>
  <span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="kn">from</span> <span class="nn">FBRank.object</span> <span class="kn">import</span> <span class="n">Club</span>

  <span class="c"># 具体原因是在 FBRank/object 下的 __init__.py 里有如下代码
</span>
  <span class="kn">from</span> <span class="nn">.League</span> <span class="kn">import</span> <span class="n">League</span>
  <span class="kn">from</span> <span class="nn">.Club</span> <span class="kn">import</span> <span class="n">Club</span>
  <span class="kn">from</span> <span class="nn">.Player</span> <span class="kn">import</span> <span class="n">Player</span>
  </code></pre></figure>


  </div>

</article>

        
<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'allianzcortex-me'; // required: replace example with your forum shortname
        // var disqus_developer = 1; // Comment out when the site is live
        var disqus_identifier = "/2015/03/11/Python-Import-Mechanism/";

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



    </main>
    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Pro Land
    </p>

  </div>

</footer>


  </body>

</html>
